Iniciamos nuevo módulo: Sección 11: Base de Datos MySQL: configurando MySQL
Iniciamos nuevo módulo: Sección 12: Base de Datos PostgreSQL: configurando en
Iniciamos nuevo módulo: Sección 13: Trazabilidad distribuida con Spring Cloud Sleuth y Zipkin
	- Descargarmos el jar de Zipkin en https://zipkin.io/pages/quickstart.html (latest release)
	- Por defecto se despliega en el http://your_host:9411/zipkin/ (descrito en https://github.com/openzipkin/zipkin/)
	- Para instalar RabbitMQ:
	-- https://rabbitmq.com/-> Get Started -> Download + Installation ->  Chocolatey or Installer  -> Chocolatey
	-- Ruta por defecto http://localhost:15672/ (el puerto del servidor es 5672, es distinto al de la consola de admin)
	-- Credenciales guest/guest
	- Para configurar Zipkin con MySQL
	-- https://zipkin.io/ -> The source code is on GitHub as openzipkin/zipkin -> zipkin-server -> En la documentación de este apartado explica cómo conectarlo a MySQL
	-- Editamos zipkin.cmd para añadir las variables de entorno de MySQL
	-- Creamos en MySQL la BD zipkin con utf8 - utf8-bin
	-- Agregamos el usuairo zipkin con autentificación estandar (con los datos usados en el script .cmd) con todos los permisos sobre Object right (select, update, ...) y nada más
	-- En github, donde está la documentación de MySQL para Zipkin, en "apply the schema" y luego "schema DDL" podemos obtener el script que hay que ejecutar (poner al principio use zipkin; para que se ejecute en esa BD)
Iniciamos nuevo módulo: Sección 14: Desplegando Microservicios en Contenedores Docker
	- Tuve varios problemas tras instalarlo y ejecutarlo. Me ayudó seguir estos pasos https://www.adictosaltrabajo.com/2020/06/04/utilizar-docker-con-wsl-2-en-windows-10/ y el enlace de error del propio Docker
	- Primero vamos a publicar el servidor de configuraciones. Para ello hay que generar el jar: springboot-servicio-config-server>mvnw.cmd clean package
	- Creamos el fichero Dockfile en el proyecto para configurar la instancia.
	-- EXPOSE indica el puerto usado, en el caso del servidor de configuración tenemos el 8888
	- Cuando se tenga creado el fichero, desde el PowerShell, en la ruta donde esté el Dockerfile, ejecutamos: docker build -t config-server:v1 .
	- Ejecutando "docker images" podremos ver la lista de imágenes y debe aparecer la que hemos creado
	- Creamos una red donde estarán todos los miscroservicios, MySQL, etc. Para ello ejecutamos:  docker network create nombrered. Por ejemplo: docker network create cursomicroservicios
	- Lanzamos la imagen:  docker run -p 8888:8888 --name config-server --network cursomicroservicios config-server:v1
	-- Primero definimos el puerto externo y luego el puero interno (El que configuramos el proyecto)
	- Para ver todas las acciones que podemos hacer sobre contenedores: docker container COMMAND
	- Para listar todos los contenedores activos es docker container ls -a (debemos poner -a para que liste todos, no sólo los activos)
	- Creamos la imagen para eureka-server: docker build -t servicio-eureka-server:v1 .
	- Y lo instanciamos: docker run -ti --init -p 8761:8761 --name servicio-eureka-server --network cursomicroservicios servicio-eureka-server:v1
		-- Con el -ti --init consigo que funcione el Ctrl + c en la consola para parar el proceso
	- Otros comandos
	-- docker ps - Lista los containers
	-- docker logs -f ID_CONTAINER - Mostrar los logs y seguirlo
	- Creamos una imagen para MySQL
	-- En https://hub.docker.com/ se pueden buscar las imágenes disponibles
	-- En la propia documentación de la imagen, vemos que se instala con docker pull mysql y usaremos la versión 8: docker pull mysql:8
	-- Para parar el MySQL en local: net stop MySQL80
	-- docker run -p 3306:3306 --name microservicios-mysql8 --network cursomicroservicios -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=sb_spring_cloud -d mysql:8
	- Creamos una imagen para PostgreSQL (La buscamos en hub.docker)
	-- docker pull postgres:12-alpine
	-- docker run -p 5432:5432 --name microservicios-postgres12 --network cursomicroservicios -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=sb_springboot_cloud -d postgres:12-alpine
	- Creamos la imagen del servicio de productos
	-- No exponemos el puerto porque en el caso de productos es dinámico
	-- Al compilar saltamos los tests, ya que no podrá conectar a MySQL
	-- Genero la imagen: docker build -t servicio-productos:v1 .
	-- Arrancamos la imagen, como el puerto es dinámico ponemos -P: docker run -P --name servicio-productos --network cursomicroservicios -d servicio-productos:v1
	- Levantar todas las imágenes hasta ahora
	-- docker run -p 8888:8888 --name config-server --network cursomicroservicios -d config-server:v1
	-- docker run -p 8761:8761 --name servicio-eureka-server --network cursomicroservicios -d servicio-eureka-server:v1
	-- docker run -p 3306:3306 --name microservicios-mysql8 --network cursomicroservicios -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=sb_spring_cloud -d mysql:8
	-- docker run -p 5432:5432 --name microservicios-postgres12 --network cursomicroservicios -e POSTGRES_PASSWORD=postgres -e POSTGRES_DB=db_springboot_cloud -d postgres:12-alpine
	-- docker run -P --name servicio-productos --network cursomicroservicios -d servicio-productos:v1
	-- docker run -p 8090:8090 --name servicio-zuul-server --network cursomicroservicios -d servicio-zuul-server:v1
	-- docker run -P --name servicio-usuarios --network cursomicroservicios -d servicio-usuarios:v1
	- Creamos la imagen del servicio Zuul
	-- Al compilar saltamos los tests, ya que no podrá conectar a MySQL: mvnw.cmd clean package -DskipTests
	-- Genero la imagen: docker build -t servicio-zuul-server:v1 .
	-- Arrancamos la imagen: docker run -p 8090:8090 --name servicio-zuul-server --network cursomicroservicios -d servicio-zuul-server:v1
	- Creamos la imagen del servicio Usuarios
	-- Al compilar saltamos los tests, ya que no podrá conectar a MySQL: mvnw.cmd clean package -DskipTests
	-- Genero la imagen: docker build -t servicio-usuarios:v1 .
	-- Arrancamos la imagen: docker run -P --name servicio-usuarios --network cursomicroservicios -d servicio-usuarios:v1
	- Creamos la imagen del servicio Oauth
	-- Al compilar saltamos los tests, ya que no podrá conectar a MySQL: mvnw.cmd clean package -DskipTests
	-- Genero la imagen: docker build -t servicio-oauth:v1 .
	-- Arrancamos la imagen: docker run -P --name servicio-oauth --network cursomicroservicios -d servicio-oauth:v1
	- Creamos la imagen del servicio Items
	-- Al compilar saltamos los tests, ya que no podrá conectar a MySQL: mvnw.cmd clean package -DskipTests
	-- Genero la imagen: docker build -t servicio-items:v1 .
	-- Arrancamos la imagen: docker run -P --name servicio-items --network cursomicroservicios -d servicio-items:v1
	- Configurando RabbitMQ
	-- Lo buscamos en docker hub: docker pull rabbitmq:3.8-management-alpine
	-- Lo lanzamos: docker run -p 15672:15672 -p 5672:5672 --name microservicios-rabbit38 --network cursomicroservicios -d rabbitmq:3.8-management-alpine
	-- Indico dos puertos porque usa uno para el envío de mensajes y otro para el administrador web
	- Configurando Zipkin
	-- Realizar los mismos pasos que en local, para el esquema MySQL de docker
	-- Creo una carpeta (lo he puesto donde están los fuentes de los microservicios) donde añado el jar del servidor Zipkin y el Dockfile
	-- En ese directorio: docker build -t zipkin-server:v1 .
	-- docker run -p 9411:9411 --name zipkin-server --network cursomicroservicios -d -e RABBIT_ADDRESSES=microservicios-rabbit38:5672 -e STORAGE_TYPE=mysql -e MYSQL_USER=zipkin -e MYSQL_PASS=zipkin123456 -e MYSQL_HOST=microservicios-mysql8 zipkin-server:v1
	-- docker inspect ID_CONTAINER -> Muestra información del contenedor, por ejemplo podemos ver la IP del servidor Zipkin y así en la consola de Rabbit ver que realmente está conectada esa IP
	- Configurando nombre de host de RabbitMQ en repositorio: Al poner la configuración de Zipkin y RabbitMQ en el servidor de configuraciones, no tendremos que regenerar el jar de todos los servicios implicados, sólo reiniciar las instancias con docker restart
	- Compopose
	-- Para finalizar todos los contenedores a la vez: docker stop $(docker ps -q) y para eliminarlas docker rm $(docker ps -aq)
	-- Creo una carpeta donde poner el fichero docker-compose.yml. Estando en esta carpeta, teniendo ya el fichero configurado, ejecutamos docker-compose up
	